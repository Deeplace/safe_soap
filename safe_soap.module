<?php

/**
 * @file
 * SafeSoapClient wrapper class.
 */

/**
 * Error code what occur when WSDL cache could not be created.
 */
define('SAFE_SOAP_CACHE_ERROR', 1);

/**
 * A child of SoapClient with network failure handling support.
 */
class SafeSoapClient extends SoapClient {
  private $options = [];

  /**
   * Extended SoapClient constructor.
   *
   * SafeSoapClient constructor following extensions over
   * SoapClient::__construct():
   *  - $options['certificate_chain'] - path to file containing both client
   *    auth certificate chain and server certificate chain. This is workaround
   *    for libcurl compiled against NSS (vs. OpenSSL) which does not send
   *    chain passed via CURLOPT_SSLCERT, and requires both chains set
   *    via CURLOPT_CAINFO.
   * - $options['certificate_chain'] - path to file containing both client auth
   *      certificate chain and server certificate chain. This is workaround
   *      for libcurl compiled against NSS (vs. OpenSSL) which does not send
   *      chain passed via CURLOPT_SSLCERT, and requires both chains set via
   *      CURLOPT_CAINFO.
   * - $options['local_cert'] -  path to PEM file with private key and X509
   *     authentication certificate.
   * - $options['passphrase'] - symetric key to decode private key of client
   *     auth certificate.
   * - $options['connect_timeout'] - connect timeout in seconds set via
   *                           CURLOPT_CONNECTTIMEOUT, default value is 15.
   * - $options['timeout'] - request timeout in seconds set via CURLOPT_TIMEOUT
   *                         default value is 240.
   * @param $wsdl
   * @param array $options
   * @throws SoapFault
   */
  public function __construct($wsdl, $options = array()) {
    $this->options = $options;
    $cache_file = NULL;

    $wsdl_addr_type = parse_url($wsdl, PHP_URL_SCHEME);

    if (strncmp($wsdl_addr_type, 'http', 4) === 0) {
      $response = $this->callCurl($wsdl);
      $http_status = (int) $this->curl_statuscode;

      if (!empty($response) && $http_status >= 200 && $http_status < 300) {
        $cache_file = sys_get_temp_dir() . "/safe_soap.wsdl-" . md5($wsdl);
        $wsdl = $cache_file;
      }

      // Only fetch a new wsdl every hour.
      if (!empty($cache_file) && (!file_exists($cache_file) || filectime($cache_file) < time() - 3600)) {
        if (!file_put_contents($cache_file, $response)) {
          throw new SoapFault(SAFE_SOAP_CACHE_ERROR, "Service description unavailable");
        }
      }
    }

    parent::__construct($wsdl, $options);
  }

  /**
   * Call a url using curl.
   *
   * @param string $url
   *   URL to request.
   * @param string $data
   *   URL encoded POST params.
   * @param array $headers
   *   List of HTTP headers as strings "Key: value".
   * @return string
   *   XML SOAP response.
   * @throws SoapFault On curl connection error.
   */
  private function callCurl($url, $data = NULL, array $headers = array()) {
    $options = $this->options;
    $handle = curl_init();

    curl_setopt($handle, CURLOPT_TIMEOUT, isset($options['timeout']) ? $options['timeout'] : 240);
    curl_setopt($handle, CURLOPT_CONNECTTIMEOUT, isset($options['connect_timeout']) ? $options['connect_timeout'] : 15);
    curl_setopt($handle, CURLINFO_HEADER_OUT, TRUE);
    curl_setopt($handle, CURLOPT_HEADER, FALSE);
    curl_setopt($handle, CURLOPT_URL, $url);
    curl_setopt($handle, CURLOPT_FAILONERROR, FALSE);
    curl_setopt($handle, CURLOPT_HTTPHEADER, $headers);
    curl_setopt($handle, CURLOPT_RETURNTRANSFER, TRUE);

    if (array_key_exists('local_cert', $options)) {
      curl_setopt($handle, CURLOPT_SSLCERT, $options['local_cert']);
      if (array_key_exists('certificate_chain', $options)) {
        curl_setopt($handle, CURLOPT_SSLKEY, $options['local_cert']);
      }
      if (array_key_exists('passphrase', $options)) {
        curl_setopt($handle, CURLOPT_KEYPASSWD, $options['passphrase']);
        curl_setopt($handle, CURLOPT_SSLCERTPASSWD, $options['passphrase']);
      }
    }

    if (array_key_exists('certificate_chain', $options) && !empty($options['certificate_chain'])) {
      curl_setopt($handle, CURLOPT_CAINFO, $options['certificate_chain']);
    }

    if (isset($data)) {
      curl_setopt($handle, CURLOPT_POSTFIELDS, $data);
    }

    $response = curl_exec($handle);

    $this->curl_errorno = curl_errno($handle);
    $this->curl_statuscode = curl_getinfo($handle, CURLINFO_RESPONSE_CODE);

    if (empty($response)) {
      $this->curl_errormsg = curl_error($handle);
      curl_close($handle);
      throw new SoapFault((string) $this->curl_errorno, sprintf('Network error (%s): %s', $url, $this->curl_errormsg));
    }

    curl_close($handle);

    return $response;
  }

  /**
   * Magic method.
   */
  public function __doRequest($request, $location, $action, $version, $one_way = NULL) {
    $headers = array('Content-Type: text/xml; charset=utf-8', 'SOAPAction: "' . $action . '"');
    if ($one_way) {
      $this->callCurl($location, $request, $headers);
    }
    else {
      return $this->callCurl($location, $request, $headers);
    }
  }
}
