<?php

/**
 * @file
 * SafeSoapClient wrapper class.
 */

/**
 * Error code what occur when WSDL cache could not be created.
 */
define('SAFE_SOAP_CACHE_ERROR', 1);

/**
 * A child of SoapClient with network failure handling support.
 */
class SafeSoapClient extends SoapClient {
  private $options = [];

  /**
   * Extended SoapClient constructor.
   *
   * SafeSoapClient constructor following extensions over
   * SoapClient::__construct():
   *  - $options['certificate_chain'] - path to file containing both client
   *    auth certificate chain and server certificate chain. This is workaround
   *    for libcurl compiled against NSS (vs. OpenSSL) which does not send
   *    chain passed via CURLOPT_SSLCERT, and requires both chains set
   *    via CURLOPT_CAINFO.
   */
  public function __construct($wsdl, $options = array()) {
    $this->options = $options;

    $wsdl_addr_type = parse_url($wsdl, PHP_URL_SCHEME);

    if (strncmp($wsdl_addr_type, 'http', 4) === 0) {
      $cache_file = sys_get_temp_dir() . "/safe_soap.wsdl-" . md5($wsdl);

      $url = $wsdl;
      $wsdl = $cache_file;
      // Only fetch a new wsdl every hour.
      if (!file_exists($cache_file) || filectime($cache_file) < time() - 3600) {
        if (!file_put_contents($cache_file, $this->callCurl($url))) {
          throw new SoapFault(SAFE_SOAP_CACHE_ERROR, "Service description unavailable");
        }
      }
    }

    parent::__construct($wsdl, $options);
  }

  /**
   * Call a url using curl.
   *
   * @param string $url
   *   URL to request.
   * @param string $data
   *   URL encoded POST params.
   * @param array $headers
   *  List of HTTP headers as strings "Key: value"
   * @param array $options
   *   SoapClient options with extended ones:
   *   - string passphrase - symetric key to decode private key.
   *   - string local_cert - path to PEM file with private key and X509
   *     authentication certificate.
   *   - string certificate_chain - path to PEM file public X509 certificates
   *     used to authenticate peer.
   *
   * @return string
   *   XML SOAP response.
   *
   * @throws SoapFault
   *   On curl connection error.
   */
  private function callCurl($url, $data = NULL, $headers = array()) {
    $options = $this->options;
    $handle = curl_init();
    curl_setopt($handle, CURLOPT_TIMEOUT, 240);
    curl_setopt($handle, CURLOPT_CONNECTTIMEOUT, 15);
    curl_setopt($handle, CURLINFO_HEADER_OUT, TRUE);
    curl_setopt($handle, CURLOPT_HEADER, FALSE);
    curl_setopt($handle, CURLOPT_URL, $url);
    curl_setopt($handle, CURLOPT_FAILONERROR, FALSE);
    curl_setopt($handle, CURLOPT_HTTPHEADER, $headers);
    curl_setopt($handle, CURLOPT_RETURNTRANSFER, TRUE);
    if (array_key_exists('local_cert', $options)) {
      curl_setopt($handle, CURLOPT_SSLCERT, $options['local_cert']);
      if (array_key_exists('certificate_chain', $options)) {
        curl_setopt($handle, CURLOPT_SSLKEY, $options['local_cert']);
      }
      if (array_key_exists('passphrase', $options)) {
        curl_setopt($handle, CURLOPT_KEYPASSWD, $options['passphrase']);
        curl_setopt($handle, CURLOPT_SSLCERTPASSWD, $options['passphrase']);
      }
    }
    if (array_key_exists('certificate_chain', $options) && !empty($options['certificate_chain'])) {
      curl_setopt($handle, CURLOPT_CAINFO, $options['certificate_chain']);
    }

    if (isset($data)) {
      curl_setopt($handle, CURLOPT_POSTFIELDS, $data);
    }
    $response = curl_exec($handle);
    $this->curl_errorno = curl_errno($handle);
    if ($this->curl_errorno == CURLE_OK) {
      $this->curl_statuscode = curl_getinfo($handle, CURLINFO_HTTP_CODE);
    }
    if (empty($response)) {
      $this->curl_errormsg = curl_error($handle);
      curl_close($handle);
      throw new SoapFault((string) $this->curl_errorno, sprintf('Network error (%s): %s', $url, $this->curl_errormsg));
    }
    curl_close($handle);

    return $response;
  }

  public function __doRequest($request, $location, $action, $version, $one_way = null) {
    $headers = array('Content-Type: text/xml; charset=utf-8', 'SOAPAction: "'.$action.'"');
    if ($one_way) {
      $this->callCurl($location, $request, $headers);
    } else {
      return $this->callCurl($location, $request, $headers);
    }
  }

}
